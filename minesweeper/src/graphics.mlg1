include "minesweeper/src/gamelogic"


define PCOLOR_TILE 150 + 150*256 + 150*65536
define PCOLOR_TILE_LIGHT 170 + 170*256 + 170*65536
define PCOLOR_TILE_DARK 120 + 120*256 + 120*65536
define PCOLOR_CURSOR 180 + 210*256 + 250*65536

define TILE_BEVEL_SIZE 3


global NUMBER_COLORS[] = [
    0 + 0*256 + 255*65536,
    0 + 127*256 + 0*65536,
    255 + 0*256 + 0*65536,
    0 + 0*256 + 127*65536,
    127 + 0*256 + 0*65536,
    0 + 0*256 + 0*65536,
    127 + 127*256 + 127*65536
]


fn draw_uncleared_tile(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    unpack_color(PCOLOR_TILE)
    rect(x, y, tile_size, tile_size)

    unpack_color(PCOLOR_TILE_LIGHT)
    rect(x, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y, tile_size, TILE_BEVEL_SIZE)

    unpack_color(PCOLOR_TILE_DARK)
    rect(x+tile_size-TILE_BEVEL_SIZE, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y+tile_size-TILE_BEVEL_SIZE, tile_size, TILE_BEVEL_SIZE)
}


fn draw_cleared_tile(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset
    unpack_color(PCOLOR_TILE_DARK)
    rect(x, y, tile_size, tile_size)
}


fn draw_cursor(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    unpack_color(PCOLOR_CURSOR)
    rect(x, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y, tile_size, TILE_BEVEL_SIZE)
    rect(x+tile_size-TILE_BEVEL_SIZE, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y+tile_size-TILE_BEVEL_SIZE, tile_size, TILE_BEVEL_SIZE)
}


fn draw_tile_text(text, x, y) {
    x = x * tile_size + board_x_offset + tile_size / 2
    y = y * tile_size + board_y_offset
    draw_text(text, FONT, x, y, tile_size / 8 - 2, TEXT_ALIGN_CENTER)
}


fn draw_flag(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    // Draw base
    let padding = tile_size / 6
    let base_x = x+padding
    let base_y = y + tile_size * 8 / 10
    let base_height = tile_size / 8

    color(0, 0, 0)
    rect(base_x, base_y, tile_size-padding*2, base_height)

    // Draw pole
    let pole_x = x + tile_size * 5 / 10
    let pole_y = y + padding
    let pole_width = tile_size / 10
    rect(pole_x, pole_y, pole_width, tile_size-padding*2)

    // Draw flag
    let p3y = y + tile_size / 2
    let p2y = (pole_y + p3y) / 2
    color(255, 0, 0)
    triangle(pole_x, pole_y, base_x, p2y, pole_x, p3y)
}


fn draw_mine(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    let padding = tile_size / 6

    color(0, 0, 0)
    let mine_x = x+padding
    let mine_y = y+padding
    rect(mine_x, mine_y, tile_size-padding*2, tile_size-padding*2)
}


fn draw_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    if cell_state <= E_CELL_UNCLEAR_MINE {
        // Uncleared tile
        draw_uncleared_tile(x, y)
    }
    else if cell_state <= E_CELL_FLAG_MINE {
        // Flagged tile
        draw_uncleared_tile(x, y)
        draw_flag(x, y)
    }
    else if cell_state == E_CELL_CLEAR_EMPTY {
        // Cleared tile with no mine
        draw_cleared_tile(x, y)
        let neighbors = count_neighboring_mines(x, y)
        if neighbors {
            let num_buffer[3]
            int_to_str(num_buffer, neighbors)
            let num_color = get(NUMBER_COLORS+neighbors-1)
            unpack_color(num_color)
            draw_tile_text(num_buffer, x, y)
        }
    }
    else {
        // Cleared tile with mine
        draw_cleared_tile(x, y)
        draw_mine(x, y)
    }
}


fn draw_board() {
    draw_checkerboard_background(80, PCOLOR_BG4, PCOLOR_BG3)

    let board_area = board_width * board_height

    for (let i = 0; i < board_area; i=i+1) {
        let x = i % board_width
        let y = i / board_width

        draw_cell(x, y)

        if (x == cursor_x) * (y == cursor_y) {
            draw_cursor(x, y)
        }
    }
    
    color(0, 0, 0)
    outline_rect(board_x_offset-1, board_y_offset-1, board_width*tile_size+1, board_height*tile_size+1)
}
