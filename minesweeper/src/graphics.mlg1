include "math"
include "tex"
include "minesweeper/src/gamelogic"
include "minesweeper/src/theme"


define MIN_TILE_TEXT_SIZE 1
define MAX_TILE_TEXT_SIZE 8


fn draw_uncleared_tile(x, y) {
    unpack_color(col_tile_base)
    rect(x, y, tile_size, tile_size)

    unpack_color(col_tile_pos)
    rect(x, y, tile_bevel_size, tile_size)
    rect(x, y, tile_size, tile_bevel_size)

    unpack_color(col_tile_neg)
    rect(x+tile_size-tile_bevel_size, y, tile_bevel_size, tile_size)
    rect(x, y+tile_size-tile_bevel_size, tile_size, tile_bevel_size)
}


fn draw_cleared_tile(x, y) {
    unpack_color(col_tile_neg)
    rect(x, y, tile_size, tile_size)
}


fn draw_cursor(x, y) {
    let cursor_size = tile_bevel_size
    unpack_color(col_cursor)
    rect(x, y, cursor_size, tile_size)
    rect(x, y, tile_size, cursor_size)
    rect(x+tile_size-cursor_size, y, cursor_size, tile_size)
    rect(x, y+tile_size-cursor_size, tile_size, cursor_size)
}


fn draw_number_tile(number, x, y) {
    let num_buffer[3]
    int_to_str(num_buffer, number)
    let num_color = get(col_numbers+number-1)
    unpack_color(num_color)
    let text_size = clamp(tile_size / 8 - 1, MIN_TILE_TEXT_SIZE, MAX_TILE_TEXT_SIZE)
    x = x + tile_size / 2
    y = y + tile_size / 2 - text_size * 4
    draw_text(num_buffer, FONT, x, y, text_size, TEXT_ALIGN_CENTER)
}


fn draw_flag(x, y) {
    // Draw base
    let padding = tile_size / 6
    let base_x = x+padding
    let base_y = y + tile_size * 8 / 10
    let base_height = tile_size / 8

    color(0, 0, 0)
    rect(base_x, base_y, tile_size-padding*2, base_height)

    // Draw pole
    let pole_x = x + tile_size * 5 / 10
    let pole_y = y + padding
    let pole_width = tile_size / 10
    rect(pole_x, pole_y, pole_width, tile_size-padding*2)

    // Draw flag
    let p3y = y + tile_size / 2
    let p2y = (pole_y + p3y) / 2
    color(255, 0, 0)
    triangle(pole_x, pole_y, base_x, p2y, pole_x, p3y)
}


fn draw_mine(x, y) {
    let padding = tile_size / 6

    color(0, 0, 0)
    let mine_x = x+padding
    let mine_y = y+padding
    rect(mine_x, mine_y, tile_size-padding*2, tile_size-padding*2)
}


fn draw_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    let sx = x * tile_size + board_x_offset
    let sy = y * tile_size + board_y_offset

    if cell_state <= E_CELL_UNCLEAR_MINE {
        // Uncleared tile
        draw_uncleared_tile(sx, sy)
    }
    else if cell_state <= E_CELL_FLAG_MINE {
        // Flagged tile
        draw_uncleared_tile(sx, sy)
        draw_flag(sx, sy)
    }
    else if cell_state == E_CELL_CLEAR_EMPTY {
        // Cleared tile with no mine
        draw_cleared_tile(sx, sy)
        let neighbors = count_neighboring_mines(x, y)
        if neighbors {
            draw_number_tile(neighbors, sx, sy)
        }
    }
    else {
        // Cleared tile with mine
        draw_cleared_tile(sx, sy)
        draw_mine(sx, sy)
    }

    // Check for cursor
    if (x == cursor_x) * (y == cursor_y) {
        draw_cursor(sx, sy)
    }
}


fn draw_board() {
    draw_checkerboard_background(80, PCOLOR_BG4, PCOLOR_BG3)

    let board_area = board_width * board_height

    for (let i = 0; i < board_area; i=i+1) {
        let x = i % board_width
        let y = i / board_width

        draw_cell(x, y)
    }
    
    color(0, 0, 0)
    outline_rect(board_x_offset, board_y_offset, board_width*tile_size, board_height*tile_size, 3)
}
