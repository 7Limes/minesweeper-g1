include "color"
include "math"
include "raster"
include "string"


// Cell enum definitions
define E_CELL_UNCLEAR_EMPTY 0
define E_CELL_UNCLEAR_MINE 1
define E_CELL_FLAG_EMPTY 2
define E_CELL_FLAG_MINE 3
define E_CELL_CLEAR_EMPTY 4
define E_CELL_CLEAR_MINE 5

define PCOLOR_TILE 150 + 150*256 + 150*65536
define PCOLOR_TILE_LIGHT 170 + 170*256 + 170*65536
define PCOLOR_TILE_DARK 120 + 120*256 + 120*65536
define PCOLOR_CURSOR 180 + 210*256 + 250*65536

define TILE_BEVEL_SIZE 3

define CURSOR_REPEAT_DELAY 10
define CURSOR_REPEAT_INTERVAL 4

define FLOODFILL_BUFFER_SIZE 112


global NUMBER_COLORS[] = [
    0 + 0*256 + 255*65536,
    0 + 127*256 + 0*65536,
    255 + 0*256 + 0*65536,
    0 + 0*256 + 127*65536,
    127 + 0*256 + 0*65536,
    0 + 0*256 + 0*65536,
    127 + 127*256 + 127*65536
]


global tile_size, board_x_offset, board_y_offset

global cursor_x, cursor_y
global cursor_repeat_timer = 0

global board[MAX_BOARD_SIZE*MAX_BOARD_SIZE]
global floodfill_buffer1[FLOODFILL_BUFFER_SIZE]
global floodfill_buffer2[FLOODFILL_BUFFER_SIZE]


fn start_game() {
    game_state = E_GAMESTATE_BOARD

    cursor_x = board_width / 2
    cursor_y = board_height / 2

    calculate_board_data()
    populate_board()
    draw_board()
}


fn game_tick() {
    move_cursor_tick()

    if A * !prev_A {
        clear_cell(cursor_x, cursor_y)
    }
    if B * !prev_B {
        flag_cell(cursor_x, cursor_y)
    }

    let prev_A = A
    let prev_B = B
}


fn calculate_board_data() {
    // Determine tile size and board offsets in pixels
    let tile_size_x = WIDTH / board_width
    let tile_size_y = HEIGHT / board_height

    if tile_size_x * board_height <= HEIGHT {
        tile_size = tile_size_x
        board_x_offset = (WIDTH - tile_size*board_width) / 2
        board_y_offset = HEIGHT/2 - tile_size*board_height/2
    }
    else {
        tile_size = tile_size_y
        board_x_offset = WIDTH/2 - tile_size*board_width/2
        board_y_offset = (HEIGHT - tile_size*board_height) / 2
    }
}


fn populate_board() {
    let area = board_width * board_height

    // Clear the board
    let board_end = board + area
    for (let p = board; p < board_end; p=p+1) {
        set(p, E_CELL_UNCLEAR_EMPTY)
    }

    // Populate the board with mines
    let mine_count = board_width * board_height * mine_density / 100
    for (let i = 0; i < mine_count; i=i+1) {
        let pos = next_rand() % area
        let board_ptr = board + pos
        let cell_state = get(board_ptr)
        while (cell_state == E_CELL_UNCLEAR_MINE) {
            pos = next_rand() % area
            board_ptr = board + pos
            cell_state = get(board_ptr)
        }
        set(board_ptr, E_CELL_UNCLEAR_MINE)
    }
}


fn move_cursor_tick() {
    let move_x = 0
    let move_y = 0

    if UP {
        move_y = move_y-1
    }
    if DOWN {
        move_y = move_y+1
    }
    if LEFT {
        move_x = move_x-1
    }
    if RIGHT {
        move_x = move_x+1
    }

    let input_sum = UP + DOWN + LEFT + RIGHT
    if input_sum {
        let move_by_repeat = (cursor_repeat_timer > CURSOR_REPEAT_DELAY) * 
                            !(cursor_repeat_timer % CURSOR_REPEAT_INTERVAL)
        
        if (cursor_repeat_timer == 0) + move_by_repeat {
            cursor_x = (cursor_x+move_x) % board_width
            cursor_y = (cursor_y+move_y) % board_height
            draw_board()
        }

        cursor_repeat_timer = cursor_repeat_timer+1
    }
    else {
        cursor_repeat_timer = 0
    }
}


fn get_cell_state(x, y) {
    let state = get(board + (x + y*board_width))
    return state
}

fn set_cell_state(x, y, state) {
    set(board + (x + y*board_width), state)
}


fn clear_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    if (cell_state >= E_CELL_FLAG_EMPTY) * (cell_state <= E_CELL_CLEAR_EMPTY)  {
        // Skip if this cell is flagged or already cleared
        return 0
    }

    if cell_state == E_CELL_UNCLEAR_EMPTY {
        set_cell_state(x, y, E_CELL_CLEAR_EMPTY)
        draw_board()
    }
}


fn flag_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    if (cell_state > E_CELL_FLAG_MINE) {
        // Cell is already cleared
        return 0
    }

    if (cell_state == E_CELL_FLAG_EMPTY) + (cell_state == E_CELL_FLAG_MINE) {
        // Cell is already flagged, unflag
        cell_state = cell_state-2
    }
    else {
        // Cell is not flagged, set a flag
        cell_state = cell_state+2
    }

    set_cell_state(x, y, cell_state)
    draw_board()
}


fn count_neighboring_mines(x, y) {
    let x_end = x+2
    let y_end = y+2
    let sum = 0

    for (let i = y-1; i < y_end; i=i+1) {
        for (let j = x-1; j < x_end; j=j+1) {
            if (i < 0) + (i >= board_height) + (j < 0) + (j >= board_width) + (i == j) {
                continue
            }
            let cell_state = get_cell_state(j, i)
            sum = sum + cell_state % 2
        }
    }

    return sum
}


fn draw_tile_border(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    unpack_color(PCOLOR_TILE_LIGHT)
    rect(x, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y, tile_size, TILE_BEVEL_SIZE)

    unpack_color(PCOLOR_TILE_DARK)
    rect(x+tile_size-TILE_BEVEL_SIZE, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y+tile_size-TILE_BEVEL_SIZE, tile_size, TILE_BEVEL_SIZE)
}


fn draw_uncleared_tile(x, y) {
    let bx = x * tile_size + board_x_offset
    let by = y * tile_size + board_y_offset

    unpack_color(PCOLOR_TILE)
    rect(bx, by, tile_size, tile_size)
    draw_tile_border(x, y)    
}


fn draw_cleared_tile(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset
    unpack_color(PCOLOR_TILE_DARK)
    rect(x, y, tile_size, tile_size)
}


fn draw_cursor(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    unpack_color(PCOLOR_CURSOR)
    rect(x, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y, tile_size, TILE_BEVEL_SIZE)
    rect(x+tile_size-TILE_BEVEL_SIZE, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y+tile_size-TILE_BEVEL_SIZE, tile_size, TILE_BEVEL_SIZE)
}


fn draw_tile_text(text, x, y) {
    x = x * tile_size + board_x_offset + tile_size / 2
    y = y * tile_size + board_y_offset
    draw_text(text, FONT, x, y, tile_size / 8 - 2, TEXT_ALIGN_CENTER)
}


fn draw_flag(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    // Draw base
    let padding = tile_size / 6
    let base_x = x+padding
    let base_y = y + tile_size * 8 / 10
    let base_height = tile_size / 8

    color(0, 0, 0)
    rect(base_x, base_y, tile_size-padding*2, base_height)

    // Draw pole
    let pole_x = x + tile_size * 5 / 10
    let pole_y = y + padding
    let pole_width = tile_size / 10
    rect(pole_x, pole_y, pole_width, tile_size-padding*2)

    // Draw flag
    let p3y = y + tile_size / 2
    let p2y = (pole_y + p3y) / 2
    color(255, 0, 0)
    triangle(pole_x, pole_y, base_x, p2y, pole_x, p3y)
}


fn draw_mine(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    let padding = tile_size / 6

    color(0, 0, 0)
    rect(x+padding, y+padding, tile_size-padding*2, tile_size-padding*2)
}


fn draw_board() {
    draw_checkerboard_background(80, PCOLOR_BG4, PCOLOR_BG3)

    let board_area = board_width * board_height

    for (let i = 0; i < board_area; i=i+1) {
        let x = i % board_width
        let y = i / board_width

        draw_cell(x, y)

        if (x == cursor_x) * (y == cursor_y) {
            draw_cursor(x, y)
        }
    }
    
    color(0, 0, 0)
    outline_rect(board_x_offset-1, board_y_offset-1, board_width*tile_size+1, board_height*tile_size+1)
}


fn draw_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    if cell_state <= E_CELL_UNCLEAR_MINE {
        // Uncleared tile
        draw_uncleared_tile(x, y)
    }
    else if cell_state <= E_CELL_FLAG_MINE {
        // Flagged tile
        draw_uncleared_tile(x, y)
        draw_flag(x, y)
    }
    else if cell_state == E_CELL_CLEAR_EMPTY {
        // Cleared tile with no mine
        draw_cleared_tile(x, y)
        let neighbors = count_neighboring_mines(x, y)
        if neighbors {
            let num_buffer[3]
            int_to_str(num_buffer, neighbors)
            let num_color = get(NUMBER_COLORS+neighbors-1)
            unpack_color(num_color)
            draw_tile_text(num_buffer, x, y)
        }
    }
    else {
        // Cleared tile with mine
        draw_cleared_tile(x, y)
        draw_mine(x, y)
    }
}