include "color"
include "math"
include "raster"


// Cell enum definitions
define E_CELL_UNCLEAR_EMPTY 0
define E_CELL_UNCLEAR_MINE 1
define E_CELL_FLAG_EMPTY 2
define E_CELL_FLAG_MINE 3
define E_CELL_CLEAR_EMPTY 4
define E_CELL_CLEAR_MINE 5


define PCOLOR_TILE 150 + 150*256 + 150*65536
define PCOLOR_TILE_LIGHT 170 + 170*256 + 170*65536
define PCOLOR_TILE_DARK 120 + 120*256 + 120*65536
define PCOLOR_CURSOR 180 + 210*256 + 250*65536

define TILE_BEVEL_SIZE 3


define CURSOR_REPEAT_DELAY 10
define CURSOR_REPEAT_INTERVAL 4


global tile_size, board_x_offset, board_y_offset

global cursor_x, cursor_y
global cursor_repeat_timer = 0

global board[MAX_BOARD_SIZE*MAX_BOARD_SIZE]


fn start_game() {
    game_state = E_GAMESTATE_BOARD

    cursor_x = board_width / 2
    cursor_y = board_height / 2

    calculate_board_data()
    populate_board()
    draw_board()
}


fn game_tick() {
    move_cursor_tick()
}


fn calculate_board_data() {
    // Determine tile size and board offsets in pixels
    let tile_size_x = WIDTH / board_width
    let tile_size_y = HEIGHT / board_height

    if tile_size_x * board_height <= HEIGHT {
        tile_size = tile_size_x
        board_x_offset = (WIDTH - tile_size*board_width) / 2
        board_y_offset = HEIGHT/2 - tile_size*board_height/2
    }
    else {
        tile_size = tile_size_y
        board_x_offset = WIDTH/2 - tile_size*board_width/2
        board_y_offset = (HEIGHT - tile_size*board_height) / 2
    }
}


fn populate_board() {
    let area = board_width * board_height

    // Clear the board
    let board_end = board + area
    for (let p = board; p < board_end; p=p+1) {
        set(p, E_CELL_UNCLEAR_EMPTY)
    }

    // Populate the board with mines
    let mine_count = board_width * board_height * mine_density / 100
    for (let i = 0; i < mine_count; i=i+1) {
        let pos = next_rand() % area
        let board_ptr = board + pos
        let cell_state = get(board_ptr)
        while (cell_state == E_CELL_UNCLEAR_MINE) {
            pos = next_rand() % area
            board_ptr = board + pos
            cell_state = get(board_ptr)
        }
        set(board_ptr, E_CELL_UNCLEAR_MINE)
    }
}


fn move_cursor_tick() {
    let move_x = 0
    let move_y = 0

    if UP {
        move_y = move_y-1
    }
    if DOWN {
        move_y = move_y+1
    }
    if LEFT {
        move_x = move_x-1
    }
    if RIGHT {
        move_x = move_x+1
    }

    let input_sum = UP + DOWN + LEFT + RIGHT
    if input_sum {
        let move_by_repeat = (cursor_repeat_timer > CURSOR_REPEAT_DELAY) * 
                            !(cursor_repeat_timer % CURSOR_REPEAT_INTERVAL)
        
        if (cursor_repeat_timer == 0) + move_by_repeat {
            draw_tile_border(cursor_x, cursor_y)
            cursor_x = (cursor_x+move_x) % board_width
            cursor_y = (cursor_y+move_y) % board_height
            draw_cursor(cursor_x, cursor_y)
        }

        cursor_repeat_timer = cursor_repeat_timer+1
    }
    else {
        cursor_repeat_timer = 0
    }
}


fn draw_tile_border(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    unpack_color(PCOLOR_TILE_LIGHT)
    rect(x, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y, tile_size, TILE_BEVEL_SIZE)

    unpack_color(PCOLOR_TILE_DARK)
    rect(x+tile_size-TILE_BEVEL_SIZE, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y+tile_size-TILE_BEVEL_SIZE, tile_size, TILE_BEVEL_SIZE)
}


fn draw_uncleared_tile(x, y) {
    let bx = x * tile_size + board_x_offset
    let by = y * tile_size + board_y_offset

    unpack_color(PCOLOR_TILE)
    rect(bx, by, tile_size, tile_size)
    draw_tile_border(x, y)    
}


fn draw_cursor(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    unpack_color(PCOLOR_CURSOR)
    rect(x, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y, tile_size, TILE_BEVEL_SIZE)
    rect(x+tile_size-TILE_BEVEL_SIZE, y, TILE_BEVEL_SIZE, tile_size)
    rect(x, y+tile_size-TILE_BEVEL_SIZE, tile_size, TILE_BEVEL_SIZE)
}


fn draw_tile_text(text, x, y) {
    x = x * tile_size + board_x_offset + tile_size / 2
    y = y * tile_size + board_y_offset
    draw_text(text, FONT, x, y, tile_size / 8 - 2, TEXT_ALIGN_CENTER)
}


fn draw_flag(x, y) {
    x = x * tile_size + board_x_offset
    y = y * tile_size + board_y_offset

    // Draw base
    let padding = tile_size / 6
    let base_x = x+padding
    let base_y = y + tile_size * 8 / 10
    let base_height = tile_size / 8

    color(0, 0, 0)
    rect(base_x, base_y, tile_size-padding*2, base_height)

    // Draw pole
    let pole_x = x + tile_size * 5 / 10
    let pole_y = y + padding
    let pole_width = tile_size / 10
    rect(pole_x, pole_y, pole_width, tile_size-padding*2)

    // Draw flag
    let p3y = y + tile_size / 2
    let p2y = (pole_y + p3y) / 2
    color(255, 0, 0)
    triangle(pole_x, pole_y, base_x, p2y, pole_x, p3y)
}


fn draw_board() {
    draw_checkerboard_background(80, PCOLOR_BG4, PCOLOR_BG3)

    let board_area = board_width * board_height

    for (let i = 0; i < board_area; i=i+1) {
        let x = i % board_width
        let y = i / board_width

        draw_uncleared_tile(x, y)

        if get(board+i) == E_CELL_UNCLEAR_MINE {
            draw_flag(x, y)
        }

        if (x == cursor_x) * (y == cursor_y) {
            draw_cursor(x, y)
        }
    }
    
    color(0, 0, 0)
    outline_rect(board_x_offset-1, board_y_offset-1, board_width*tile_size+1, board_height*tile_size+1)
}