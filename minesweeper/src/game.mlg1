include "color"
include "math"
include "raster"
include "string"
include "minesweeper/src/gamelogic"
include "minesweeper/src/graphics"

// Cursor controls
define CURSOR_REPEAT_DELAY 10
define CURSOR_REPEAT_INTERVAL 4


// Cursor data
global cursor_x, cursor_y
global cursor_repeat_timer = 0


fn start_game() {
    game_state = E_GAMESTATE_BOARD
    game_timer = 0

    cursor_x = board_width / 2
    cursor_y = board_height / 2

    calculate_board_data()
    populate_board()
    draw_board()
}


fn game_tick() {
    move_cursor_tick()

    if A * !prev_A {
        clear_cell(cursor_x, cursor_y)
    }
    if B * !prev_B {
        flag_cell(cursor_x, cursor_y)
    }

    game_timer = game_timer+1

    let prev_A = A
    let prev_B = B
}


fn move_cursor_tick() {
    let move_x = 0
    let move_y = 0

    if UP {
        move_y = move_y-1
    }
    if DOWN {
        move_y = move_y+1
    }
    if LEFT {
        move_x = move_x-1
    }
    if RIGHT {
        move_x = move_x+1
    }

    let input_sum = UP + DOWN + LEFT + RIGHT
    if input_sum {
        let move_by_repeat = (cursor_repeat_timer > CURSOR_REPEAT_DELAY) * 
                            !(cursor_repeat_timer % CURSOR_REPEAT_INTERVAL)
        
        if (cursor_repeat_timer == 0) + move_by_repeat {
            cursor_x = (cursor_x+move_x) % board_width
            cursor_y = (cursor_y+move_y) % board_height
            draw_board()
        }

        cursor_repeat_timer = cursor_repeat_timer+1
    }
    else {
        cursor_repeat_timer = 0
    }
}


fn clear_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    if (cell_state >= E_CELL_FLAG_EMPTY) * (cell_state <= E_CELL_CLEAR_EMPTY)  {
        // Skip if this cell is flagged or already cleared
        return 0
    }

    if cell_state == E_CELL_UNCLEAR_EMPTY {
        floodfill_clear(x, y)
        draw_board()
        if check_win() {
            game_state = E_GAMESTATE_ENDGAME
            show_endgame_menu(true)
        }
    }
    else if cell_state == E_CELL_UNCLEAR_MINE {
        // Hit mine
        set_cell_state(x, y, E_CELL_CLEAR_MINE)
        game_state = E_GAMESTATE_ENDGAME
        draw_board()
        show_endgame_menu(false)
    }
}


fn flag_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    if (cell_state > E_CELL_FLAG_MINE) {
        // Cell is already cleared
        return 0
    }

    if (cell_state == E_CELL_FLAG_EMPTY) + (cell_state == E_CELL_FLAG_MINE) {
        // Cell is already flagged, unflag
        cell_state = cell_state-2
    }
    else {
        // Cell is not flagged, set a flag
        cell_state = cell_state+2
    }

    set_cell_state(x, y, cell_state)
    draw_board()
}
