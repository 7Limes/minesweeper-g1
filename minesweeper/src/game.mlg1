include "color"
include "math"
include "raster"
include "string"
include "minesweeper/src/gamelogic"
include "minesweeper/src/graphics"
include "minesweeper/src/sound"
include "minesweeper/src/pause"


// Win state enum
define E_WINSTATE_NONE 0
define E_WINSTATE_WIN 1
define E_WINSTATE_LOSE -1

// Cursor controls
define CURSOR_REPEAT_DELAY 10
define CURSOR_REPEAT_INTERVAL 4

// First turn configuration
define MINIMUM_STARTING_TILES 10
define FIRST_TURN_MAX_ITERATIONS 10

define GOOD_CLEAR_THRESHOLD 5


// Cursor data
global cursor_x, cursor_y
global cursor_repeat_timer = 0

global first_turn

global quick_clear_queue[8]
global quick_clear_queue_size = 0


fn move_cursor_tick() {
    let move_x = 0
    let move_y = 0

    if UP {
        move_y = move_y-1
    }
    if DOWN {
        move_y = move_y+1
    }
    if LEFT {
        move_x = move_x-1
    }
    if RIGHT {
        move_x = move_x+1
    }

    let input_sum = UP + DOWN + LEFT + RIGHT
    if input_sum {
        let move_by_repeat = (cursor_repeat_timer > CURSOR_REPEAT_DELAY) * 
                            !(cursor_repeat_timer % CURSOR_REPEAT_INTERVAL)
        
        if (cursor_repeat_timer == 0) + move_by_repeat {
            cursor_x = (cursor_x+move_x) % board_width
            cursor_y = (cursor_y+move_y) % board_height
            draw_board()
        }

        cursor_repeat_timer = cursor_repeat_timer+1
    }
    else {
        cursor_repeat_timer = 0
    }
}


fn do_first_turn(x, y) {
    let iteration_count = 0
    while first_turn {
        iteration_count = iteration_count+1

        populate_board()
        let cell_state = get_cell_state(x, y)
        if cell_state == E_CELL_UNCLEAR_MINE {
            continue
        }
        
        if cell_state == E_CELL_UNCLEAR_EMPTY {
            let cleared_cells = floodfill_clear(x, y)
            if (cleared_cells < MINIMUM_STARTING_TILES) * (iteration_count < FIRST_TURN_MAX_ITERATIONS) {
                continue
            }
            first_turn = false
        }
    }
}


fn count_neighboring_flags(x, y) {
    let x_end = x+2
    let y_end = y+2
    let sum = 0

    for (let i = y-1; i < y_end; i=i+1) {
        for (let j = x-1; j < x_end; j=j+1) {
            if is_cell_out_of_bounds(j, i) {
                continue
            }
            if (i == y) * (j == x) {
                continue
            }
            let cell_state = get_cell_state(j, i)
            let is_flag = (cell_state == E_CELL_FLAG_EMPTY) + (cell_state == E_CELL_FLAG_MINE)
            sum = sum + is_flag
        }
    }

    return sum
}


fn queue_quick_clear_cells(x, y) {
    let x_end = x+2
    let y_end = y+2

    for (let i = y-1; i < y_end; i=i+1) {
        for (let j = x-1; j < x_end; j=j+1) {
            if is_cell_out_of_bounds(j, i) {
                continue
            }
            if (i == y) * (j == x) {
                continue
            }
            let cell_state = get_cell_state(j, i)
            if cell_state <= E_CELL_UNCLEAR_MINE {
                let cell_index = j + i*board_width
                set(quick_clear_queue+quick_clear_queue_size, cell_index)
                quick_clear_queue_size = quick_clear_queue_size+1
            }
        }
    }
}


fn clear_cell(x, y) {
    if first_turn {
        do_first_turn(x, y)
        play_tone(0, TRIANGLE_WAVE, 200, 5000, 5)
        return E_WINSTATE_NONE
    }

    let cell_state = get_cell_state(x, y)
    if (cell_state == E_CELL_FLAG_EMPTY) + (cell_state == E_CELL_FLAG_MINE)  {
        // Skip if this cell is flagged
        return E_WINSTATE_NONE
    }

    if cell_state == E_CELL_CLEAR_EMPTY {
        // Try to do quick clear
        let neighboring_mines = count_neighboring_mines(x, y)
        if neighboring_mines {
            let neighboring_flags = count_neighboring_flags(x, y)
            if neighboring_mines == neighboring_flags {
                queue_quick_clear_cells(x, y)
            }
        }
    }
    else if cell_state == E_CELL_UNCLEAR_EMPTY {
        let cleared_cells = floodfill_clear(x, y)
        if cleared_cells > GOOD_CLEAR_THRESHOLD {
            play_tone(0, TRIANGLE_WAVE, 400, 5000, 7)
        }
        else {
            play_tone(0, TRIANGLE_WAVE, 200, 5000, 5)
        }

        if check_win() {
            return E_WINSTATE_WIN
        }
    }
    else if cell_state == E_CELL_UNCLEAR_MINE {
        // Hit mine
        set_cell_state(x, y, E_CELL_CLEAR_MINE)
        play_tone(2, NOISE_WAVE, 500, 5000, 60)
        return E_WINSTATE_LOSE
    }

    return E_WINSTATE_NONE
}


fn do_quick_clear() {
    for (let i = 0; i < quick_clear_queue_size; i=i+1) {
        let cell_index = get(quick_clear_queue+i)
        let x = cell_index % board_width
        let y = cell_index / board_width
        let win_state = clear_cell(x, y)
        if win_state {
            // If there was a win or lose, return immediately
            return win_state
        }
    }
    
    quick_clear_queue_size = 0
    return E_WINSTATE_NONE
}


fn flag_cell(x, y) {
    let cell_state = get_cell_state(x, y)
    if (cell_state > E_CELL_FLAG_MINE) {
        // Cell is already cleared
        return 0
    }

    if (cell_state == E_CELL_FLAG_EMPTY) + (cell_state == E_CELL_FLAG_MINE) {
        // Cell is already flagged, unflag
        cell_state = cell_state-2
    }
    else {
        // Cell is not flagged, set a flag
        cell_state = cell_state+2
    }
    play_tone(1, SQUARE_WAVE, 250, 2000, 5)

    set_cell_state(x, y, cell_state)
}


fn start_game() {
    game_state = E_GAMESTATE_BOARD
    game_timer = 0
    first_turn = true

    cursor_x = board_width / 2
    cursor_y = board_height / 2

    calculate_board_data()
    populate_board()
    draw_board()
}


fn game_tick() {
    move_cursor_tick()

    if A * !prev_A {
        let win_state = clear_cell(cursor_x, cursor_y)
        win_state = win_state + do_quick_clear()
        draw_board()

        if win_state == E_WINSTATE_WIN {
            game_state = E_GAMESTATE_ENDGAME
            show_endgame_menu(true)
        }
        else if win_state == E_WINSTATE_LOSE {
            game_state = E_GAMESTATE_ENDGAME
            show_endgame_menu(false)
        }
    }
    if B * !prev_B * !first_turn {
        flag_cell(cursor_x, cursor_y)
        draw_board()
    }

    // Pause
    if CONTROL1 * !prev_CONTROL1 {
        game_state = E_GAMESTATE_PAUSE
        display_pause_menu()
    }

    game_timer = game_timer+1
}
