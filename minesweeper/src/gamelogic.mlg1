// Cell enum definitions
define E_CELL_UNCLEAR_EMPTY 0
define E_CELL_UNCLEAR_MINE 1
define E_CELL_FLAG_EMPTY 2
define E_CELL_FLAG_MINE 3
define E_CELL_CLEAR_EMPTY 4
define E_CELL_CLEAR_MINE 5

define FLOODFILL_BUFFER_SIZE 112


// Board data
global tile_size, board_x_offset, board_y_offset

// Board buffers
global board[MAX_BOARD_SIZE*MAX_BOARD_SIZE]
global floodfill_buffer1[FLOODFILL_BUFFER_SIZE]
global floodfill_buffer2[FLOODFILL_BUFFER_SIZE]


fn get_cell_state(x, y) {
    let state = get(board + (x + y*board_width))
    return state
}


fn set_cell_state(x, y, state) {
    set(board + (x + y*board_width), state)
}


fn calculate_board_data() {
    // Determine tile size and board offsets in pixels
    let tile_size_x = WIDTH / board_width
    let tile_size_y = HEIGHT / board_height

    if tile_size_x * board_height <= HEIGHT {
        tile_size = tile_size_x
        board_x_offset = (WIDTH - tile_size*board_width) / 2
        board_y_offset = HEIGHT/2 - tile_size*board_height/2
    }
    else {
        tile_size = tile_size_y
        board_x_offset = WIDTH/2 - tile_size*board_width/2
        board_y_offset = (HEIGHT - tile_size*board_height) / 2
    }
}


fn populate_board() {
    let area = board_width * board_height

    // Clear the board
    let board_end = board + area
    for (let p = board; p < board_end; p=p+1) {
        set(p, E_CELL_UNCLEAR_EMPTY)
    }

    // Populate the board with mines
    let mine_count = board_width * board_height * mine_density / 100
    for (let i = 0; i < mine_count; i=i+1) {
        let pos = next_rand() % area
        let board_ptr = board + pos
        let cell_state = get(board_ptr)
        while (cell_state == E_CELL_UNCLEAR_MINE) {
            pos = next_rand() % area
            board_ptr = board + pos
            cell_state = get(board_ptr)
        }
        set(board_ptr, E_CELL_UNCLEAR_MINE)
    }
}


fn is_cell_out_of_bounds(x, y) {
    if (y < 0) + (y >= board_height) {
        return 1
    }
    if (x < 0) + (x >= board_width) {
        return 1
    }
    return 0
}


fn count_neighboring_mines(x, y) {
    let x_end = x+2
    let y_end = y+2
    let sum = 0

    for (let i = y-1; i < y_end; i=i+1) {
        for (let j = x-1; j < x_end; j=j+1) {
            if is_cell_out_of_bounds(j, i) {
                continue
            }
            if (i == y) * (j == x) {
                continue
            }
            let cell_state = get_cell_state(j, i)
            sum = sum + cell_state % 2
        }
    }

    return sum
}


fn queue_neighbors(next_buffer_end, x, y) {
    let x_end = x+2
    let y_end = y+2

    for (let i = y-1; i < y_end; i=i+1) {
        for (let j = x-1; j < x_end; j=j+1) {
            if is_cell_out_of_bounds(j, i) {
                continue
            }
            if (i == y) * (j == x) {
                continue
            }
            let neighbor_state = get_cell_state(j, i)
            if neighbor_state == E_CELL_UNCLEAR_EMPTY {
                set_cell_state(j, i, E_CELL_CLEAR_EMPTY)
                set(next_buffer_end, j + i*board_width)
                next_buffer_end = next_buffer_end+1
            }
        }
    }

    return next_buffer_end
}


fn floodfill_clear(seed_x, seed_y) {
    let current_buffer = floodfill_buffer1
    let next_buffer = floodfill_buffer2
    let current_buffer_end = current_buffer+1
    let next_buffer_end = next_buffer

    let total_cleared_cells = 0

    set_cell_state(seed_x, seed_y, E_CELL_CLEAR_EMPTY)
    set(current_buffer, seed_x + seed_y*board_width)

    let current_buffer_ptr = current_buffer
    while (current_buffer_ptr < current_buffer_end) {
        total_cleared_cells = total_cleared_cells+1
        let current_cell = get(current_buffer_ptr)
        let x = current_cell % board_width
        let y = current_cell / board_width

        let neighbors = count_neighboring_mines(x, y)
        if !neighbors {
            next_buffer_end = queue_neighbors(next_buffer_end, x, y)
        }
        
        current_buffer_ptr = current_buffer_ptr+1
        
        if current_buffer_ptr >= current_buffer_end {
            // Swap current buffer and next buffer
            let temp = current_buffer
            current_buffer = next_buffer
            next_buffer = temp

            current_buffer_ptr = current_buffer
            current_buffer_end = next_buffer_end
            next_buffer_end = next_buffer
        }
    }
    
    return total_cleared_cells
}


fn check_win() {
    let board_end = board + board_width * board_height
    for (let p = board; p < board_end; p=p+1) {
        let cell_state = get(p)
        if cell_state == E_CELL_UNCLEAR_EMPTY {
            return 0
        }
    }

    return 1
}