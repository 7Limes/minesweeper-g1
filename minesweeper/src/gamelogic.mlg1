// Cell enum definitions
define E_CELL_UNCLEAR_EMPTY 0
define E_CELL_UNCLEAR_MINE 1
define E_CELL_FLAG_EMPTY 2
define E_CELL_FLAG_MINE 3
define E_CELL_CLEAR_EMPTY 4
define E_CELL_CLEAR_MINE 5

define FLOODFILL_BUFFER_SIZE 112


// Board data
global tile_size, board_x_offset, board_y_offset

// Board buffers
global board[MAX_BOARD_SIZE*MAX_BOARD_SIZE]
global floodfill_buffer1[FLOODFILL_BUFFER_SIZE]
global floodfill_buffer2[FLOODFILL_BUFFER_SIZE]


fn get_cell_state(x, y) {
    let state = get(board + (x + y*board_width))
    return state
}


fn set_cell_state(x, y, state) {
    set(board + (x + y*board_width), state)
}


fn calculate_board_data() {
    // Determine tile size and board offsets in pixels
    let tile_size_x = WIDTH / board_width
    let tile_size_y = HEIGHT / board_height

    if tile_size_x * board_height <= HEIGHT {
        tile_size = tile_size_x
        board_x_offset = (WIDTH - tile_size*board_width) / 2
        board_y_offset = HEIGHT/2 - tile_size*board_height/2
    }
    else {
        tile_size = tile_size_y
        board_x_offset = WIDTH/2 - tile_size*board_width/2
        board_y_offset = (HEIGHT - tile_size*board_height) / 2
    }
}


fn populate_board() {
    let area = board_width * board_height

    // Clear the board
    let board_end = board + area
    for (let p = board; p < board_end; p=p+1) {
        set(p, E_CELL_UNCLEAR_EMPTY)
    }

    // Populate the board with mines
    let mine_count = board_width * board_height * mine_density / 100
    for (let i = 0; i < mine_count; i=i+1) {
        let pos = next_rand() % area
        let board_ptr = board + pos
        let cell_state = get(board_ptr)
        while (cell_state == E_CELL_UNCLEAR_MINE) {
            pos = next_rand() % area
            board_ptr = board + pos
            cell_state = get(board_ptr)
        }
        set(board_ptr, E_CELL_UNCLEAR_MINE)
    }
}

fn count_neighboring_mines(x, y) {
    let x_end = x+2
    let y_end = y+2
    let sum = 0

    for (let i = y-1; i < y_end; i=i+1) {
        for (let j = x-1; j < x_end; j=j+1) {
            if (i < 0) + (i >= board_height) + (j < 0) + (j >= board_width) + (i == j) {
                continue
            }
            let cell_state = get_cell_state(j, i)
            sum = sum + cell_state % 2
        }
    }

    return sum
}